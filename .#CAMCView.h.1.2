// CAMCView.h : CCAMCView 类的接口
//
#include <afxmt.h>
#include "MyWintab.h"
#include <Windows.h>
#pragma once

class CCAMCDoc;
class CUnit;
class CPaintBrush;


class CCAMCView : public CScrollView
{
protected: // 仅从序列化创建
	CCAMCView();
	DECLARE_DYNCREATE(CCAMCView)
// 属性
public:
	CCAMCDoc* GetDocument() const;

// 操作
public:
	int m_CurrentTool;
	CUnit * m_pCurrentDraw;
	int	m_CurrentDrawStatus;

private:
	CWintab m_wt;//从手写设备获得信息的接口
	UINT m_prs;
	CPaintBrush * m_pBrush;
	unsigned int  m_penState;
	COLORREF m_colorTmp;
public:
	UINT GetPress(int x,int y){
		return m_wt.GetPress();
	}
	// 重写
// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL OnEraseBkgnd(CDC* pDC);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
//	virtual void OnInitialUpdate(); // 构造后第一次调用
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//所以绘制的工作都在这里进行
	virtual void DrawInMemory(CDC* pMemDC);
// 实现
public:
	virtual ~CCAMCView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	//{{AFX_MSG(CCAMCView)

	afx_msg void OnRectbutton();
	afx_msg void OnUpdateRectbutton(CCmdUI* pCmdUI);
	afx_msg void OnPenbutton();
	afx_msg void OnUpdatePenbutton(CCmdUI* pCmdUI);
	afx_msg void OnMagicbutton();
	afx_msg void OnUpdateMagicbutton(CCmdUI* pCmdUI);
	afx_msg void OnRubberbutton();
	afx_msg void OnUpdateRubberbutton(CCmdUI* pCmdUI);
	afx_msg void OnZoominbutton();
	afx_msg void OnUpdateZoominbutton(CCmdUI* pCmdUI);
	afx_msg void OnZoomoutbutton();
	afx_msg void OnUpdateZoomoutbutton(CCmdUI* pCmdUI);
	afx_msg void OnLinebutton();
	afx_msg void OnUpdateLinebutton(CCmdUI* pCmdUI);
	afx_msg void OnBsplinebutton();
	afx_msg void OnUpdateBsplinebutton(CCmdUI* pCmdUI);
	afx_msg void OnCurvebutton();
	afx_msg void OnUpdateCurvebutton(CCmdUI* pCmdUI);
	afx_msg void OnObjectbutton();
	afx_msg void OnUpdateObjectbutton(CCmdUI* pCmdUI);
	afx_msg void OnMovebutton();
	afx_msg void OnUpdateMovebutton(CCmdUI* pCmdUI);
	afx_msg void OnColorPickbutton();
	afx_msg void OnUpdateColorPickbutton(CCmdUI* pCmdUI);

	afx_msg LRESULT OnWTPacket(WPARAM, LPARAM);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()


public:
	virtual void OnInitialUpdate();
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);

	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);

	afx_msg void OnInsertPoint();
	afx_msg void OnDeletePoint();
	afx_msg void OnUpdatePoint();
	afx_msg void OnPassingpointsSelect();
	afx_msg void OnEndPoints();
public:	
	void MagicWand(CPoint point,int Threshold);
	void Objectpick(CPoint point,int Threshold);
	void ObjectSelect(CPoint point,CDC* pDC);
	void LPToCP(POINT& point);
	void CPToLP(POINT& point);
	void FilledColor(CPoint point,COLORREF color);
	void ZOOM_IN();
	void ZOOM_OUT();
	void MoveLayer( CPoint point);
	POINT GetCanvasOffset();
	FCObjCanvas& GetCanvas();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnColorsamping();
	afx_msg void OnObjectpick();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

};

#ifndef _DEBUG  // CAMCView.cpp 的调试版本
inline CCAMCDoc* CCAMCView::GetDocument() const
   { return reinterpret_cast<CCAMCDoc*>(m_pDocument); }
#endif

